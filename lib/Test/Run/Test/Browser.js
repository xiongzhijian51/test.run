Class('Test.Run.Test.Browser', {
    
    isa : Test.Run.Test,
    
    have : {
        iframe : null,
        
        timeoutIds : null,
        
        finished : false
    },
    
    
    after : {
        
        initialize : function () {
            this.timeoutIds = {}
        }
        
    },
    
    
    methods : {
        
        beginAsync : function (time) {
            var me = this
            
            var timeoutId = this.topScope.setTimeout(function () {
                me.endAsync(timeoutId)
            }, time || 1e4)
            
            this.timeoutIds[timeoutId] = true
            
            return timeoutId
        },
        
        
        endAsync : function (timeoutId) {
            var counter = 0
            
            if (!timeoutId) Joose.O.each(this.timeoutIds, function (value, name) {
                timeoutId = name
                if (counter++) throw "Calls to endAsync without argument should only be performed if you have single beginAsync statement" 
            })
            
            this.topScope.clearTimeout(timeoutId)
            delete this.timeoutIds[timeoutId]
            
            if (this.finished) this.finalize()
        },
        
        
        finalize : function () {
            this.finished = true
            
            if (!Joose.O.isEmpty(this.timeoutIds)) return
            
            this.SUPER()
        }
        
    }
    
})
//eof Test.Run.Test.Browser

/**
 * @namespace Test.Run.Test
 * @class Test.Run.Test.Browser
 * @extends Test.Run.Test
 * This class represent a test file, which is supposed to be executed in browser. Thus it assumes the presence of setTimeout/clearTimeout 
 * functions and provides the ability of asynchornous testsing.<br><br>
 * 
 * Before testing assertions asynchronously, you need to obtain a timeoutId from the {@link #beginAsync} call. As the assertions were checked, the timeoutId should be
 * released with the {@link #endAsync} call.<br>
 * Test will not be finished until there are active timeouts. If the {@link #endAsync} was not called, it will called implicitly after the time interval, passed to the {@link #beginAsync},
 * will expire.<br><br>
 * Example: <pre>
StartTest(function(t){

    t.plan(1)
    
    t.diag('Starting..')
    
    var async1 = <b>t.beginAsync(3000)</b>
    
    Ext.Ajax.request({
        url: '/foo?bar=baz',
        
        success: function (response) {
            t.ok(response == 'response', 'Response is valid')
            
            <b>t.endAsync(async1)</b>
        },
    })

    
    ...
})
</pre>

 * @author Nickolay (SamuraiJack) Platonov 
 * @version 0.01
 */


/**
 * @property iframe The iframe in which this test is executing 
 * @type {DOMObject}
 */


/**
 * @property timeoutIds The hash which keep the timeout ids, generated by beginAsync call
 * @type {Object}
 */


/**
 * @property finished The sign whether this test has finished execution. Harness may be still notified, until there are active "asynchronous frames"
 * @type {Boolean}
 */


/**
 * This method starts the asynchronous testing. The test will not finished, until the specified time will finish 
 * @method beginAsync
 * @param {Number?} time The maximum number of milliseconds, which this "async frame" can last, defaults to 10000
 * @return {Number} The timeoutId, which can be used in endAsync call
 */


/**
 * This method finalize the "asynchronous frame" started with beginAsync.  
 * @method endAsync
 * @param {Number} timeoutId The timeoutId, returned by beginAsync call
 */


/**
 * This method is 'protected' and should be used only for class extensions.
 * This method is overriden to support beginAsync/endAsync calls
 * @method finalize
 */
